<%
@title = "Climb!"
@back_url = climbs_path
@extra_header = button_to "Done", { action: "complete", climb_id: @climb.id }, method: :post, class: "btn btn-primary btn-sm", data: { test: 'complete' }
@hide_current_climb_link = true
%>

<div class="card">
  <div class="row mx-1 mb-1 flex flex-row justify-content-between">
    <input type="date" value="<%= @climb.climbed_at %>" class="form-control w-50" id="climbedAt">
    <button class="btn bg-white w-25 visually-hidden" id="lock">🔓</button>
  </div>

  <div class="row mx-1 mb-1 flex flex-row" id="routeSetsContainer" data-test="route-set-picker">
    <% @active_route_sets.each do |route_set| %>
      <button style="background-color: <%= route_set.color %>" data-route-set-id="<%= route_set.id %>" data-colour="<%= route_set.color %>" class="btn">
        <span>
          <%= route_set.color.titleize %>
        </span>
      </button>
    <% end %>
  </div>

  <div id="map" class="map">
    <div id="floorBackgroundColour"></div>
    <img src="/GroundFloor.png" id="floorBackground" style="opacity: 0.8; background-color: pink" />
  </div>
</div>

<script>
  $(() => {
    const $map = $('#map')
    const $routeSets = $('#routeSetsContainer > button')
    const $climbedAt = $('#climbedAt')
    const $done = $('#done')
    const $lock = $('#lock')
    const routeSets = <%= raw @routes.to_json %>
    const previousStates = <%= raw previous_states.to_json %>
    let $currentRouteSetBtn = null
    let $routes = []

    const initRouteStates = () => {
      const initialRouteStates = <%= raw @climb.route_states.to_json %>
      Object.keys(routeSets).forEach(routeSetKey => {
        routeSets[routeSetKey].forEach(route => {
          const routeState = initialRouteStates.filter(initialRouteState => initialRouteState.route_id == route.id)[0]

          if(!routeState)
            return

          route.status = routeState.status
        })
      })
    }

    const changeRoute = (e) => {
      if(isLocked())
        return

      $routes.forEach($route => {
        $route.remove()
      })
      $routes = []

      if($currentRouteSetBtn) {
        $map.removeClass($currentRouteSetBtn.data('colour'))
        $currentRouteSetBtn.removeClass('current')
        $currentRouteSetBtn.removeAttr('disabled')
      }

      $currentRouteSetBtn = e ? $(e.currentTarget) : $($routeSets[0])
      const routeSetId = $currentRouteSetBtn.data('routeSetId')
      const colour = $currentRouteSetBtn.data('colour')

      const newRoutes = routeSets[routeSetId]
      newRoutes.forEach(addRoute)

      $map.addClass(colour)
      $currentRouteSetBtn.addClass('current')
      $currentRouteSetBtn.attr('disabled', true)
    }

    const addRoute = route => {
      const $route = $(`<div class="route" data-route-id="${route.id}" style="left: ${(route.pos_x / 400) * 100}%; top: ${(route.pos_y / 873) * 100}%">${icon(route)}</div>`)
      $route.click(() => clickRoute(route))
      route.$elem = $route
      $map.append($route)
      $routes.push($route)
    }

    const clickRoute = route => {
      if(isLocked())
          return

      const statusOrder = ['failed', 'sent', 'flashed']
      const nextStatusIndex = statusOrder.indexOf(route.status) + 1
      route.status = statusOrder[nextStatusIndex]

      route.$elem.text(icon(route))

      updateServer()
    }

    const toggleLock = () => {
      $lock.attr('disabled', 'disabled')

      if(isLocked()) {
        $lock.wakeLock.release().then(() => {
          $lock.wakeLock = null
          $lock.removeAttr('disabled')
          $lock.text('🔓')
          $map.css('opacity', 1)
        })
      } else {
        navigator.wakeLock.request('screen').then(lock => {
          $lock.wakeLock = lock
          $lock.removeAttr('disabled')
          $lock.text('🔒')
          $map.css('opacity', 0.1)
        })
      }
    }

    const isLocked = () => {
      return !!$lock.wakeLock
    }

    const debounce = (func, wait, immediate) => {
      var timeout;
      return function () {
        var context = this, args = arguments;
        var later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    };

    const updateServer = debounce(() => {
      const routeStates = Object.keys(routeSets).map(routeSetId => 
        routeSets[routeSetId].map(route => ({
          routeId: route.id,
          status: route.status || 'not_attempted'
        }))
      ).flat()

      $.ajax({
        url: '<%= climb_path(@climb) %>', 
        data: {
          climbed_at: $climbedAt.val(),
          route_states: routeStates
        },
        method: 'patch'
      })
    }, 1000)

    const icon = route => {
      switch(route.status) {
        case 'flashed':
          return '⚡'
        case 'sent':
          return '✔'
        case 'failed':
          return '❌'
      }

      switch(previousStates[route.id]) {
        case 'sent':
          return '🟢'
        case 'failed':
          return '🟡'
        default:
          return '🔴'
      }
    }

    $climbedAt.change(updateServer)
    $routeSets.click(changeRoute)
    initRouteStates()
    changeRoute()

    if('wakeLock' in navigator) {
      $lock.removeClass('visually-hidden')
      $lock.click(toggleLock)
    }
  })

  $(() => {
    const $routeSetsContainer = $('#routeSetsContainer')
    const routeSetContainerTop = $routeSetsContainer[0].getBoundingClientRect().y + document.documentElement.scrollTop - 10
    $('#routeSets').css({ maxWidth: $routeSetsContainer.width() })

    const updateFixedRouteSet = () => {
      if(document.documentElement.scrollTop > routeSetContainerTop)
        $routeSetsContainer.addClass('fix-to-top')
      else
        $routeSetsContainer.removeClass('fix-to-top')
    }

    $(document).scroll(updateFixedRouteSet)
    updateFixedRouteSet()
  })
</script>
